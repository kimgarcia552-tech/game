<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Super Hero Flappy - Fixed</title>
<style>
html,body{
    margin:0;
    padding:0;
    overflow:hidden;
    background:#000;
    font-family:monospace;
}
canvas{
    display:block;
    margin:auto;
    image-rendering:pixelated;
}
#restartBtn{
    position:absolute;
    left:50%;
    top:60%;
    transform:translate(-50%,-50%);
    padding:12px 24px;
    font-size:18px;
    display:none;
    cursor:pointer;
}
</style>
</head>
<body>

<canvas id="game"></canvas>
<button id="restartBtn">Play Again</button>

<script>
// ================= SETUP =================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

const restartBtn = document.getElementById("restartBtn");

// ================= IMAGE =================
const heroImg = new Image();
heroImg.src = "bird.png";

// ================= CONSTANTS =================
const GRAVITY = 1800;
const FLAP = -550;
const TERMINAL = 900;
const PIPE_WIDTH = 90;
let BASE_GAP = 240;

let pipes = [];
let score = 0;
let best = localStorage.getItem("best") || 0;
let state = "start";
let difficulty = 1;
let isNight = false;
let lastTime = 0;
let boostMode = false;

// ================= SAFE AUDIO =================
let audioCtx;
function initAudio(){
    if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}
function sound(freq,dur){
    if(!audioCtx) return;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.connect(g);
    g.connect(audioCtx.destination);
    o.frequency.value=freq;
    o.type="square";
    o.start();
    g.gain.setValueAtTime(0.1,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
    o.stop(audioCtx.currentTime+dur);
}

// ================= HERO =================
class Hero{
    constructor(){
        this.x=W/4;
        this.y=H/2;
        this.vel=0;
        this.angle=0;
        this.trail=[];
        this.cape=[];
        for(let i=0;i<6;i++){
            this.cape.push({x:this.x,y:this.y});
        }
    }
    flap(){
        this.vel=FLAP;
        sound(600,0.1);
    }
    update(dt){
        let gravity = boostMode ? GRAVITY*0.6 : GRAVITY;
        this.vel+=gravity*dt;
        if(this.vel>TERMINAL) this.vel=TERMINAL;
        this.y+=this.vel*dt;

        this.angle += ((this.vel/800)-this.angle)*0.1;

        // Trail (optimized)
        this.trail.push({x:this.x,y:this.y,life:1});
        if(this.trail.length>12) this.trail.shift();

        // Cape physics
        let prev={x:this.x-20,y:this.y};
        for(let p of this.cape){
            p.x+=(prev.x-p.x)*0.25;
            p.y+=(prev.y-p.y)*0.25+2;
            prev=p;
        }
    }
    draw(){
        // Glow trail
        for(let t of this.trail){
            ctx.beginPath();
            ctx.arc(t.x,t.y,12*t.life,0,Math.PI*2);
            ctx.fillStyle=boostMode?
                "rgba(255,80,0,0.3)":
                "rgba(255,255,0,0.2)";
            ctx.fill();
            t.life-=0.05;
        }

        // Cape
        ctx.beginPath();
        ctx.moveTo(this.x-20,this.y);
        for(let p of this.cape){
            ctx.lineTo(p.x,p.y);
        }
        ctx.strokeStyle="red";
        ctx.lineWidth=5;
        ctx.stroke();

        // Hero image
        ctx.save();
        ctx.translate(this.x,this.y);
        ctx.rotate(this.angle);
        ctx.drawImage(heroImg,-35,-35,70,70);
        ctx.restore();
    }
}
const hero=new Hero();

// ================= PIPE =================
class Pipe{
    constructor(){
        this.gap=BASE_GAP-difficulty*10;
        this.top=Math.random()*(H-this.gap-200)+100;
        this.x=W;
        this.passed=false;
    }
    update(dt){
        let speed=300+difficulty*40;
        if(boostMode) speed*=1.4;
        this.x-=speed*dt;
    }
    draw(){
        ctx.fillStyle=isNight?"#0f0":"#2ecc40";
        ctx.fillRect(this.x,0,PIPE_WIDTH,this.top);
        ctx.fillRect(this.x,this.top+this.gap,PIPE_WIDTH,H);
    }
}

// ================= INPUT =================
function handleInput(){
    initAudio();

    if(state==="start"){
        state="play";
        return;
    }
    if(state==="play"){
        hero.flap();
    }
    if(state==="gameover"){
        reset();
    }
}

window.addEventListener("keydown",e=>{
    if(e.code==="Space") handleInput();
    if(e.code==="ShiftLeft") boostMode=true;
});
window.addEventListener("keyup",e=>{
    if(e.code==="ShiftLeft") boostMode=false;
});
window.addEventListener("touchstart",()=>{
    handleInput();
    boostMode=true;
    setTimeout(()=>boostMode=false,250);
});
document.body.addEventListener("touchmove",e=>e.preventDefault(),{passive:false});

restartBtn.onclick=reset;

// ================= GAME =================
function spawnPipe(){
    pipes.push(new Pipe());
}
setInterval(()=>{
    if(state==="play") spawnPipe();
},2000);

function reset(){
    score=0;
    difficulty=1;
    pipes=[];
    hero.y=H/2;
    hero.vel=0;
    state="play";
    restartBtn.style.display="none";
}

function update(dt){
    if(state!=="play") return;

    hero.update(dt);

    pipes.forEach(p=>p.update(dt));
    pipes=pipes.filter(p=>p.x+PIPE_WIDTH>0);

    pipes.forEach(p=>{
        if(!p.passed && p.x<hero.x){
            p.passed=true;
            score++;
            sound(800,0.1);
            difficulty=1+score/5;
            if(score%10===0) isNight=!isNight;
        }

        const r=30;
        if(hero.x+r>p.x && hero.x-r<p.x+PIPE_WIDTH){
            if(hero.y-r<p.top || hero.y+r>p.top+p.gap){
                gameOver();
            }
        }
    });

    if(hero.y>H || hero.y<0) gameOver();
}

function gameOver(){
    state="gameover";
    sound(200,0.3);
    if(score>best){
        best=score;
        localStorage.setItem("best",best);
    }
    restartBtn.style.display="block";
}

// ================= DRAW =================
function background(){
    const g=ctx.createLinearGradient(0,0,0,H);
    if(isNight){
        g.addColorStop(0,"#001848");
        g.addColorStop(1,"#000");
    }else{
        g.addColorStop(0,"#70c5ce");
        g.addColorStop(1,"#fff");
    }
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);
}

function draw(){
    background();
    pipes.forEach(p=>p.draw());
    hero.draw();

    ctx.fillStyle="white";
    ctx.font="24px monospace";
    ctx.fillText("Score: "+score,20,40);
    ctx.fillText("Best: "+best,20,70);

    if(state==="start"){
        ctx.fillText("Tap or Press Space",W/2-140,H/2);
    }
    if(state==="gameover"){
        ctx.fillText("Game Over!",W/2-80,H/2-40);
    }
}

// ================= LOOP =================
function loop(t){
    let dt=(t-lastTime)/1000;
    if(dt>0.03) dt=0.03;
    lastTime=t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
